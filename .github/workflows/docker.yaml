name: Docker

on:
  workflow_call:
    inputs:
      registry:
        description: "Docker registry"
        type: string
        default: ghcr.io
      registry_username:
        description: "Docker registry username. Default: github.actor"
        type: string
      file:
        description: "Path to Dockerfile"
        type: string
        default: Dockerfile
      context:
        description: "Path to Docker build context"
        type: string
        default: "."
      image_name:
        description: "Docker image name. Default: github.repository"
        type: string
      target:
        description: "Target stage to build"
        type: string
      build_args:
        description: "Docker build args"
        type: string
      tags:
        description: "Docker tags"
        type: string
        default: |
          type=schedule
          type=ref,event=branch
          type=ref,event=tag
          type=ref,event=pr
          type=sha,format=long
      archs:
        description: >-
          Architectures to include in multi-arch manifest. Only the native
          architecture image will be built as `<image-name>-<arch>`, e.g.
          `devcontainer-amd64`. Other platform images must exist in the
          registry as `<image-name>-<arch>`. The multi-arch build will include
          the latest `<image-name>-<arch>` images in the multi-arch manifest.
        type: string
      push:
        description: "If true, push the build to the registry"
        type: boolean
        default: true
      startup_test:
        description: "Run startup test with docker-compose"
        type: boolean
      startup_compose_file:
        description: "Path to docker-compose.yaml file to use for startup test"
        type: string
        default: docker-compose.yaml
      startup_image_env_name:
        description: "Environment variables to set as the built image name"
        type: string
      submodules:
        description: "Checkout submodules"
        type: string
    secrets:
      registry_password:
        description: "Docker registry password, defaults to GITHUB_TOKEN"
      build_args:
        description: "Docker build args with secrets"
      ssh_private_keys:
        description: "SSH private keys, e.g. GitHub Deploy Keys"

jobs:
  build_and_push:
    name: Build and push Docker image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    env:
      TAGS: ${{ inputs.tags }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
        with:
          submodules: ${{ inputs.submodules }}

      - name: Configure image tags for multiarch manifest
        if: inputs.archs
        run: |
          ARCH=`uname -m`
          case $ARCH in
          amd64 | x86_64) 
              ARCH=amd64
              ;;
          aarch64 | arm64) 
              ARCH=arm64
              ;;
          esac

          TAGS=`echo "$TAGS" | sed "s/\$/-$ARCH/"`

          echo "TAGS=$(printf '%q' "$TAGS")" | tee -a $GITHUB_ENV

      # Workaround for lack of support for `secrets` in `if` clause
      - name: Detect SSH
        id: ssh
        run: |
          if ${{ secrets.ssh_private_keys != null }}; then
            echo "Found SSH private keys"
            echo "::set-output name=use::true"
          fi

      - name: Configure SSH Agent
        if: steps.ssh.outputs.use
        uses: webfactory/ssh-agent@v0.5.4
        with:
          ssh-private-key: ${{ secrets.ssh_private_keys }}

      - name: Configure Docker build args
        id: docker_args
        env:
          SCOPE: ${{ runner.os }}-${{ runner.arch }}-docker-${{ hashFiles(inputs.file) }}
        run: |
          echo "::set-output name=cache_from::type=gha,scope=$SCOPE"
          echo "::set-output name=cache_to::type=gha,scope=${SCOPE},mode=max"

          if [[ -n "$SSH_AUTH_SOCK" ]]; then
            echo "::set-output name=ssh::default=$SSH_AUTH_SOCK"
          fi

      - name: Save Git and SSH config
        run: |
          if ${{ steps.ssh.outputs.use != null }}; then
            if [[ ! -f .gitconfig ]]; then
              cp ~/.gitconfig .gitconfig
            fi
            if [[ ! -f .sshconfig ]]; then
              cp ~/.ssh/config .sshconfig
            fi
          fi
          touch .gitconfig
          touch .sshconfig

      # Workaround: https://github.com/docker/build-push-action/issues/461
      - name: Setup Docker buildx
        uses: docker/setup-buildx-action@79abd3f86f79a9d68a23c75a09a9a85889262adf
        with:
          driver-opts: network=host
          install: true

      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v3
        with:
          images: ${{ inputs.registry }}/${{ inputs.image_name || github.repository }}
          tags: ${{ env.TAGS }}

      - name: Build Docker image
        id: docker
        uses: docker/build-push-action@v2
        with:
          file: ${{ inputs.file }}
          context: ${{ inputs.context }}
          build-args: |
            ${{ secrets.build_args }}
            ${{ inputs.build_args }}
          ssh: ${{ steps.docker_args.outputs.ssh }}
          cache-from: ${{ steps.docker_args.outputs.cache_from }}
          cache-to: ${{ steps.docker_args.outputs.cache_to }}
          load: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          target: ${{ inputs.target }}

      - name: Save Docker image archive
        id: image
        env:
          TAGS: ${{ fromJSON(steps.docker.outputs.metadata)['image.name'] }}
          SHA: ${{ github.sha }}
        run: |
          IFS=$', ' command eval 'TAGS=($TAGS)'
          TAG="${TAGS[0]}"
          docker tag "$TAG" "$SHA"
          docker save "$TAG" -o "${SHA}.tar"
          echo "::set-output name=archive::${SHA}.tar"
          echo "::set-output name=sha::$SHA"

      - name: Run startup tests
        if: inputs.startup_test
        env:
          FILE: ${{ inputs.startup_compose_file }}
          IMAGE_ENV_NAME: ${{ inputs.startup_image_env_name }}
          BUILT_TAG: ${{ steps.image.outputs.sha }}
        run: |
          if [[ -n "$IMAGE_ENV_NAME" ]]; then
            eval "export ${IMAGE_ENV_NAME}=$BUILT_TAG"
          fi

          echo '::group::docker compose up'
          docker compose --file "$FILE" up --wait
          EXIT_CODE=$?
          echo '::endgroup::'

          echo '::group::docker compose logs'
          docker compose logs
          echo '::endgroup::'

          echo '::group::docker compose down'
          docker compose kill
          docker compose down
          echo '::endgroup::'

          exit $EXIT_CODE

      - name: Scan for vulnerabilities with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          input: ${{ steps.image.outputs.archive }}
          # format: sarif
          # output: trivy-results.sarif

      # TODO(jacob): Integrate Trivy with GitHub Security
      # - name: Upload Trivy scan results to the GitHub Security tab
      #   uses: github/codeql-action/upload-sarif@v1
      #   with:
      #     sarif_file: trivy-results.sarif

      # TODO(jacob): Configure Dockle lint
      - name: Lint with Dockle
        env:
          INPUT: ${{ steps.image.outputs.archive }}
        run: >
          docker run --rm
          --volume "$PWD/$INPUT:/tmp/$INPUT"
          goodwithtech/dockle:latest
          --input "/tmp/$INPUT"

      - name: Log into Docker registry
        if: inputs.push
        uses: docker/login-action@v1
        with:
          registry: ${{ inputs.registry }}
          username: ${{ inputs.registry_username || github.actor }}
          password: ${{ secrets.registry_password || github.token }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v2
        with:
          file: ${{ inputs.file }}
          context: ${{ inputs.context }}
          build-args: |
            ${{ secrets.build_args }}
            ${{ inputs.build_args }}
          ssh: ${{ steps.docker_args.outputs.ssh }}
          cache-from: ${{ steps.docker_args.outputs.cache_from }}
          cache-to: ${{ steps.docker_args.outputs.cache_to }}
          push: ${{ inputs.push }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          target: ${{ inputs.target }}

      - name: Create multiarch manifest
        id: manifest
        if: inputs.archs
        env:
          ARCHS: ${{ inputs.archs }}
          BASE_TAGS: ${{ inputs.tags }}
          BASE_MANIFEST: ${{ inputs.registry }}/${{ inputs.image_name || github.repository }}
          BUILT_TAGS: ${{ fromJSON(steps.docker.outputs.metadata)['image.name'] }}
        run: |
          IFS=$'\n ' command eval 'ARCHS=($ARCHS)'
          IFS=$'\n ' command eval 'BASE_TAGS=($BASE_TAGS)'
          BASE_MANIFEST="${BASE_MANIFEST,,}"

          IFS=', ' command eval 'BUILT_TAGS=($BUILT_TAGS)'
          BUILT_TAGS="^($(IFS=\|; echo "${BUILT_TAGS[*]}"))$"

          MANIFESTS=()
          for BASE_TAG in "${BASE_TAGS[@]}"; do
            MANIFEST="${BASE_MANIFEST}:${BASE_TAG}"

            AMEND=()
            for PLATFORM in "${ARCHS[@]}"; do
              IMAGE_NAME="${MANIFEST}-${PLATFORM}"
              echo "::group::docker pull $IMAGE_NAME"
              if [[ "$IMAGE_NAME" =~ $BUILT_TAGS ]]; then
                echo "Not pulling built image $IMAGE_NAME"
              else
                docker pull "$IMAGE_NAME"
              fi
              echo '::endgroup::'
              AMEND+=(--amend "$IMAGE_NAME")
            done

            echo "::group::docker manifest create"
            docker manifest create "$MANIFEST" "${AMEND[@]}"
            echo '::endgroup::'
            MANIFESTS+=("$MANIFEST")
          done

          MANIFESTS=`IFS=$'\n'; echo "${MANIFESTS[*]}"`
          MANIFESTS=`printf '%q' "$MANIFESTS"`
          echo "::set-output name=manifests::$MANIFESTS"

      - name: Push multiarch manifest
        if: inputs.push && steps.manifest.outputs.manifests
        env:
          MANIFESTS: ${{ steps.manifest.outputs.manifests }}
        run: echo "$MANIFESTS" | xargs -n1 docker manifest push
